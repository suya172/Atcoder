{
	"Print to console": {
	"prefix": "tmp",
	"body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"",
		"#pragma GCC target(\"avx\")",
		"#pragma GCC optimize(\"O3\")",
		"#pragma GCC optimize(\"unroll-loops\")",
		"struct Fast {Fast() {std::cin.tie(0); ios::sync_with_stdio(false);}} fast;",
		"",
		"using ull = unsigned long long;",
		"using ll = long long;",
		"using ld = long double;",
		"const ll MOD=1000000007;",
		"const ld EPS=1e-14;",
		"const int INF=1e+9;",
		"const ll LINF=1e+18;",
		"// pair",
		"using pii = pair<int, int>;",
		"// vector",
		"using vi = vector<int>;",
		"using vl = vector<long>;",
		"using vll = vector<ll>;",
		"using vvi = vector<vi>;",
		"using vvl = vector<vl>;",
		"using vvll = vector<vll>;",
		"using vs = vector<string>;",
		"using vpii = vector<pii>;",
		"using vb = vector<bool>;",
		"using vvb = vector<vb>;",
		"// unordered set",
		"using usi = unordered_set<int>;",
		"using usll = unordered_set<ll>;",
		"using uss = unordered_set<string>;",
		"",
		"#define pb push_back",
		"#define mp make_pair",
		"#define um unordered_map",
		"#define siz size()",
		"#define YESNO(bool) if(bool){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}",
		"#define yesno(bool) if(bool){cout<<\"yes\"<<endl;}else{cout<<\"no\"<<endl;}",
		"#define YesNo(bool) if(bool){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}",
		"#define all(v) v.begin(),v.end()",
		"#define rall(v) v.rbegin(),v.rend()",
		"#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );",
		"#define itn int",
		"#define stirng string",
		"",
		"/* REP macro */",
		"#define reps(i, a, n) for (ll i = (a); i < (ll)(n); ++i)",
		"#define rep(i, n) reps(i, 0, n)",
		"#define rrep(i, n) reps(i, 1, n + 1)",
		"#define repd(i,n) for(ll i=n-1;i>=0;i--)",
		"#define rrepd(i,n) for(ll i=n;i>=1;i--)",
		"",
		"/* debug */",
		"// 標準エラー出力を含む提出はrejectされる場合もあるので注意",
		"#define debug(x) cerr << \"\\033[33m(line:\" << __LINE__ << \") \" << #x << \": \" << x << \"\\033[m\" << endl;",
		"",
		"/* func */",
		"inline int in_int() {int x; cin >> x; return x;}",
		"inline ll in_ll() {ll x; cin >> x; return x;}",
		"inline double in_double() {{double x; cin >> x; return x;}}",
		"inline string in_str() {string x; cin >> x; return x;}",
		"inline int ctoi(char c) {return c - '0';}",
		"// vector_finder: (arg)elementを vectorの先頭から(arg)search_lengthまで先頭から検索し、boolを返す",
		"// (arg)search_length: 走査するベクトル長の上限(先頭から何要素目までを検索対象とするか、1始まりで)",
		"template <typename T> inline bool vector_finder(std::vector<T> vec, T element, unsigned int search_length) {",
		"    auto itr = std::find(vec.begin(), vec.end(), element);",
		"    size_t index = std::distance( vec.begin(), itr );",
		"    if (index == vec.size() || index >= search_length) {return false;} else {return true;}",
		"}",
		"template <typename T> inline void print(const vector<T>& v, string s = \" \")",
		"    {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}",
		"template <typename T, typename S> inline void print(const pair<T, S>& p)",
		"    {cout << p.first << \" \" << p.second << endl;}",
		"template <typename T> inline void print(const T& x) {cout << x << \"\\n\";}",
		"template <typename T, typename S> inline void print(const vector<pair<T, S>>& v)",
		"    {for (auto&& p : v) print(p);}",
		"template <typename T, typename S> inline void print(const map<T, S>& m)",
		"    {for (auto&& p : m) print(p);}",
		"inline void dprint(const double& d,ll n = 10){cout << fixed << setprecision(n) << d << endl;}",
		"// 第一引数と第二引数を比較し、第一引数(a)をより大きい/小さい値に上書き",
		"template <typename T> inline bool chmin(T& a, const T& b) {bool compare = a > b; if (a > b) a = b; return compare;}",
		"template <typename T> inline bool chmax(T& a, const T& b) {bool compare = a < b; if (a < b) a = b; return compare;}",
		"",
		"int main(){",
		"   ",
		"}"
	],
	"description": ""
	},
	"inputvec": {
		"body": [
			"vector<${1:int}> ${2:vec}(${3:N});",
			"for (int i = 0; i < $3; i++) cin >> $2[i];",
			""
		],
		"description": "inputvec",
		"prefix": "ivec"
	},
	"inputint": {
		"body": [
			"int ${1:N}; cin>>$1;"
		],
		"description": "inputint",
		"prefix": "iint"
	},
	"inputtwoint": {
		"body": [
			"int ${1:N},${2:M}; cin>>$1>>$2;"
		],
		"description": "inputtwoint",
		"prefix": "iints"
	},
	"inputstring": {
		"body": [
			"string ${1:S}; cin>>$1;"
		],
		"description": "inputstring",
		"prefix": "istr"
	},
	"inputll": {
		"body": [
			"ll ${1:N}; cin>>$1;"
		],
		"description": "inputll",
		"prefix": "ill"
	},
	"inputtwoll": {
		"body": [
			"ll ${1:N},${2:M}; cin>>$1>>$2;"
		],
		"description": "inputtwoll",
		"prefix": "ills"
	},
	"inputdouble": {
		"body": [
			"double ${1:N},${2:M}; cin>>$1>>$2;"
		],
		"description": "inputdouble",
		"prefix": "idouble"
	},
	"meguru_binary_search": {
		"body": [
			"    // めぐる式二分探索",
			"    // (ng, ok] or [ok, ng)",
			"    // 条件を満たす最小(最大)のindex okと",
			"    // 条件を満たさない最大(最小)のindex ngを探索する",
			"    int ok = ${1:n};  // 条件を満たすindex",
			"    int ng = ${2:-1};   // 条件を満たさないindex",
			"    while (abs(ok - ng) > 1) {",
			"        int mid = (ok + ng) / 2;",
			"        if (${3:isSatisfy}(mid))",
			"            ok = mid;",
			"        else",
			"            ng = mid;",
			"    }",
			""
		],
		"description": "meguru_binary_search",
		"prefix": "meguru_binary_search"
	},
	"uf": {
		"prefix": "UF",
		"body": [
			"struct UnionFind {",
			"    vector<ll> par; // par[i]:iの親の番号(例) par[3] = 2 : 3の親が2",
			"    vector<ll> siz",
			"",
			"    UnionFind(ll N) : par(N),siz(N,1LL) { //最初は全てが根であるとして初期化",
			"        for(ll i = 0; i < N; i++) par[i] = i;",
			"    }",
			"",
			"    void init(ll sz_) {",
			"       par.resize(sz_);",
			"       siz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった",
			"       for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身",
			"    }",
			"",
			"    ll root(ll x) { // データxが属する木の根を再帰で得る:root(x) = {xの木の根}",
			"        if (par[x] == x) return x;",
			"        return par[x] = root(par[x]);",
			"    }",
			"",
			"    bool merge(ll x, ll y) { // xとyの木を併合",
			"        ll rx = root(x); //xの根をrx",
			"        ll ry = root(y); //yの根をry",
			"        if (rx == ry) return false; //xとyの根が同じ(=同じ木にある)時はそのまま",
			"        if(siz[rx] < siz[ry]) swap(rx,ry);",
			"        siz[rx] += siz[ry];",
			"        par[ry] = rx; //xとyの根が同じでない(=同じ木にない)時:xの根rxをyの根ryにつける",
			"        return true;",
			"    }",
			"",
			"    bool issame(ll x, ll y) { // 2つのデータx, yが属する木が同じならtrueを返す",
			"        ll rx = root(x);",
			"        ll ry = root(y);",
			"        return rx == ry;",
			"    }",
			"",
			"   ll size(ll x) {",
			"        return siz[root(x)];",
			"    }",
			"}"
		],
		"description": "UnionFind木"
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"/* RMQ:[0,n-1] について、区間ごとの最小値を管理する構造体",
			"    update(i,x): i 番目の要素を x に更新。O(log(n))",
			"    query(a,b): [a,b) での最小の要素を取得。O(log(n))",
			"*/",
			"template <typename T>",
			"struct RMQ {",
			"    const T INF = numeric_limits<T>::max();",
			"    int n;         // 葉の数",
			"    vector<T> dat; // 完全二分木の配列",
			"    RMQ(int n_) : n(), dat(n_ * 4, INF) { // 葉の数は 2^x の形",
			"        int x = 1;",
			"        while (n_ > x) {",
			"            x *= 2;",
			"        }",
			"        n = x;",
			"    }",
			"",
			"    void update(int i, T x) {",
			"        i += n - 1;",
			"        dat[i] = x;",
			"        while (i > 0) {",
			"            i = (i - 1) / 2;  // parent",
			"            dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);",
			"        }",
			"    }",
			"",
			"    // the minimum element of [a,b)",
			"    T query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
			"    T query_sub(int a, int b, int k, int l, int r) {",
			"        if (r <= a || b <= l) {",
			"            return INF;",
			"        } else if (a <= l && r <= b) {",
			"            return dat[k];",
			"        } else {",
			"            T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
			"            T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
			"            return min(vl, vr);",
			"        }",
			"    }",
			"};"
		],
		"description": "区間内の最小値を求める"
	},
	"iscross": {
		"prefix": "iscross",
		"body": [
			"bool iscross(pair<int,int>p1,pair<int,int>p2,pair<int,int>p3,pair<int,int>p4){",
			"  ll t1,t2,t3,t4;",
			"  t1 = f(p1, p2, p3);",
			"  t2 = f(p1, p2, p4);",
			"  t3 = f(p3, p4, p1);",
			"  t4 = f(p3, p4, p2);",
			"  return t1*t2 < 0.0 && t3*t4 < 0.0;",
			"}"
		],
		"description": "二点を結ぶ線分同士が交わるかどうか"
	},
	"nck": {
		"prefix": "nck",
		"body": [
			"ll nCk(int n, int k) {",
			"    ll x = 1; // n!の初期値",
			"    ll y = 1; // (n-k)!の初期値",
			"    ll z = 1; // k!の初期値",
			"",
			"    // 演算ごとにMODをとる",
			"    rep(i, n) x = (x * (n - i)) % MOD; // n!を計算",
			"    rep(i, n - k) y = (y * (n - k - i)) % MOD; // (n-k)!を計算",
			"    rep(i, k) z = (z * (k - i)) % MOD; // k!を計算",
			"",
			"    // 先に分母をMODの世界で計算してあげる",
			"    ll yz = (y * z) % MOD;",
			"",
			"    // 定義通りに計算",
			"    return (x / (yz)) % MOD;",
			"}",
			""
		],
		"description": "重複なし組み合わせ"
	},
	"Priority_Sum": {
		"prefix": "Priority_Sum",
		"body": [
			"template< typename T, typename Compare = less< T >, typename RCompare = greater< T > >",
			"struct PrioritySumStructure {",
			"",
			"  size_t k;",
			"  T sum;",
			"",
			"  priority_queue< T, vector< T >, Compare > in, d_in;",
			"  priority_queue< T, vector< T >, RCompare > out, d_out;",
			"",
			"  PrioritySumStructure(int k) : k(k), sum(0) {}",
			"",
			"  void modify() {",
			"    while(in.size() - d_in.size() < k && !out.empty()) {",
			"      auto p = out.top();",
			"      out.pop();",
			"      if(!d_out.empty() && p == d_out.top()) {",
			"        d_out.pop();",
			"      } else {",
			"        sum += p;",
			"        in.emplace(p);",
			"      }",
			"    }",
			"    while(in.size() - d_in.size() > k) {",
			"      auto p = in.top();",
			"      in.pop();",
			"      if(!d_in.empty() && p == d_in.top()) {",
			"        d_in.pop();",
			"      } else {",
			"        sum -= p;",
			"        out.emplace(p);",
			"      }",
			"    }",
			"    while(!d_in.empty() && in.top() == d_in.top()) {",
			"      in.pop();",
			"      d_in.pop();",
			"    }",
			"  }",
			"",
			"  T query() const {",
			"    return sum;",
			"  }",
			"",
			"  void insert(T x) {",
			"    in.emplace(x);",
			"    sum += x;",
			"    modify();",
			"  }",
			"",
			"  void erase(T x) {",
			"    assert(size());",
			"    if(!in.empty() && in.top() == x) {",
			"      sum -= x;",
			"      in.pop();",
			"    } else if(!in.empty() && RCompare()(in.top(), x)) {",
			"      sum -= x;",
			"      d_in.emplace(x);",
			"    } else {",
			"      d_out.emplace(x);",
			"    }",
			"    modify();",
			"  }",
			"",
			"  void set_k(size_t kk) {",
			"    k = kk;",
			"    modify();",
			"  }",
			"",
			"  size_t get_k() const {",
			"    return k;",
			"  }",
			"",
			"  size_t size() const {",
			"    return in.size() + out.size() - d_in.size() - d_out.size();",
			"  }",
			"};",
			"",
			"template< typename T >",
			"using MaximumSum = PrioritySumStructure< T, greater< T >, less< T > >;",
			"",
			"template< typename T >",
			"using MinimumSum = PrioritySumStructure< T, less< T >, greater< T > >;",
			""
		],
		"description": "スライド区間内の小さい・大きい順にK個の和"
	},
	"isPrime": {
		"prefix": "isPrime",
		"body": [
			"bool IsPrime(int num)",
			"{",
			"    if (num < 2) return false;",
			"    else if (num == 2) return true;",
			"    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く",
			"",
			"    double sqrtNum = sqrt(num);",
			"    for (int i = 3; i <= sqrtNum; i += 2)",
			"    {",
			"        if (num % i == 0)",
			"        {",
			"            // 素数ではない",
			"            return false;",
			"        }",
			"    }",
			"",
			"    // 素数である",
			"    return true;",
			"}"
		],
		"description": "素数判定"
	},
	"powmod": {
		"prefix": "powmod",
		"body": [
			"ll powmod(ll x,ll y){",
			"    ll res=1;",
			"    for(ll i=0;i<y;i++){",
			"      res=res*x%MOD;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"tmpy": {
        "prefix": "tmpy",
        "body": [
            "#include<bits/stdc++.h>",
            "#include<ext/pb_ds/assoc_container.hpp>",
            "#include<ext/pb_ds/tree_policy.hpp>",
            "#include<ext/pb_ds/tag_and_trait.hpp>",
            "#define overload4(_1, _2, _3, _4, name, ...) name",
            "#define rep1(i, n) for (ll i = 0; i < ll(n); ++i)",
            "#define rep2(i, s, n) for (ll i = ll(s); i < ll(n); ++i)",
            "#define rep3(i, s, n, d) for(ll i = ll(s); i < ll(n); i+=d)",
            "#define rep(...) overload4(__VA_ARGS__,rep3,rep2,rep1)(__VA_ARGS__)",
            "#define rrep1(i, n) for (ll i = ll(n)-1; i >= 0; i--)",
            "#define rrep2(i, n, t) for (ll i = ll(n)-1; i >= (ll)t; i--)",
            "#define rrep3(i, n, t, d) for (ll i = ll(n)-1; i >= (ll)t; i-=d)",
            "#define rrep(...) overload4(__VA_ARGS__,rrep3,rrep2,rrep1)(__VA_ARGS__)",
            "#define all(a) a.begin(),a.end()",
            "#define rall(a) a.rbegin(),a.rend()",
            "#define SUM(a) accumulate(all(a),0LL)",
            "#define MIN(a) *min_element(all(a))",
            "#define MAX(a) *max_element(all(a))",
            "#define SORT(a) sort(all(a));",
            "#define REV(a) reverse(all(a));",
            "#define SZ(a) int(a.size())",
            "#define popcount(x) __builtin_popcountll(x)",
            "#define pf push_front",
            "#define pb push_back",
            "#define ef emplace_front",
            "#define eb emplace_back",
            "#define ppf pop_front",
            "#define ppb pop_back",
            "#ifdef __LOCAL",
            "#define debug(...) { cout << #__VA_ARGS__; cout << \": \"; print(__VA_ARGS__); cout << flush; }",
            "#else",
            "#define debug(...) void(0);",
            "#endif",
            "#define INT(...) int __VA_ARGS__;scan(__VA_ARGS__)",
            "#define LL(...) ll __VA_ARGS__;scan(__VA_ARGS__)",
            "#define STR(...) string __VA_ARGS__;scan(__VA_ARGS__)",
            "#define CHR(...) char __VA_ARGS__;scan(__VA_ARGS__)",
            "#define DBL(...) double __VA_ARGS__;scan(__VA_ARGS__)",
            "#define LD(...) ld __VA_ARGS__;scan(__VA_ARGS__)",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "using ll = long long;",
            "using ld = long double;",
            "using P = pair<int, int>;",
            "using LP = pair<ll, ll>;",
            "using vi = vector<int>;",
            "using vvi = vector<vi>;",
            "using vvvi = vector<vvi>;",
            "using vl = vector<ll>;",
            "using vvl = vector<vl>;",
            "using vvvl = vector<vvl>;",
            "using vd = vector<double>;",
            "using vvd = vector<vd>;",
            "using vs = vector<string>;",
            "using vc = vector<char>;",
            "using vvc = vector<vc>;",
            "using vb = vector<bool>;",
            "using vvb = vector<vb>;",
            "using vp = vector<P>;",
            "using vvp = vector<vp>;",
            "using vlp = vector<LP>;",
            "using vvlp = vector<vlp>;",
            "template<class T>",
            "using PQ = priority_queue<T>;",
            "template<class T>",
            "using PQrev = priority_queue<T, vector<T>, greater<T>>;",
            "",
            "template<class S, class T>",
            "istream &operator>>(istream &is, pair<S, T> &p) { return is >> p.first >> p.second; }",
            "",
            "template<class S, class T>",
            "ostream &operator<<(ostream &os, const pair<S, T> &p) { return os << '{' << p.first << \", \" << p.second << '}'; }",
            "",
            "template<class S, class T, class U>",
            "istream &operator>>(istream &is, tuple<S, T, U> &t) { return is >> get<0>(t) >> get<1>(t) >> get<2>(t); }",
            "",
            "template<class S, class T, class U>",
            "ostream &operator<<(ostream &os, const tuple<S, T, U> &t) {",
            "    return os << '{' << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << '}';",
            "}",
            "",
            "template<class T>",
            "istream &operator>>(istream &is, vector<T> &v) {",
            "    for (T &t: v) { is >> t; }",
            "    return is;",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const vector<T> &v) {",
            "    os << '[';",
            "    rep(i, v.size()) os << v[i] << (i == int(v.size() - 1) ? \"\" : \", \");",
            "    return os << ']';",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const deque<T> &v) {",
            "    os << '[';",
            "    rep(i, v.size()) os << v[i] << (i == int(v.size() - 1) ? \"\" : \", \");",
            "    return os << ']';",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const set<T> &st) {",
            "    os << '{';",
            "    auto it = st.begin();",
            "    while (it != st.end()) {",
            "        os << (it == st.begin() ? \"\" : \", \") << *it;",
            "        it++;",
            "    }",
            "    return os << '}';",
            "}",
            "",
            "template<class T>",
            "ostream &operator<<(ostream &os, const multiset<T> &st) {",
            "    os << '{';",
            "    auto it = st.begin();",
            "    while (it != st.end()) {",
            "        os << (it == st.begin() ? \"\" : \", \") << *it;",
            "        it++;",
            "    }",
            "    return os << '}';",
            "}",
            "",
            "template<class T, class U>",
            "ostream &operator<<(ostream &os, const map<T, U> &mp) {",
            "    os << '{';",
            "    auto it = mp.begin();",
            "    while (it != mp.end()) {",
            "        os << (it == mp.begin() ? \"\" : \", \") << *it;",
            "        it++;",
            "    }",
            "    return os << '}';",
            "}",
            "",
            "template<class T>",
            "void vecout(const vector<T> &v, char div = '\\n') {",
            "    rep(i, v.size()) cout << v[i] << (i == int(v.size() - 1) ? '\\n' : div);",
            "}",
            "",
            "template<class T>",
            "bool constexpr chmin(T &a, T b) {",
            "    if (a > b) {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
            "",
            "template<class T>",
            "bool constexpr chmax(T &a, T b) {",
            "    if (a < b) {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
            "",
            "void scan() {}",
            "",
            "template<class Head, class... Tail>",
            "void scan(Head &head, Tail &... tail) {",
            "    cin >> head;",
            "    scan(tail...);",
            "}",
            "",
            "template<class T>",
            "void print(const T &t) { cout << t << '\\n'; }",
            "",
            "template<class Head, class... Tail>",
            "void print(const Head &head, const Tail &... tail) {",
            "    cout << head << ' ';",
            "    print(tail...);",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator+=(vector<T> &v, T x) {",
            "    for (T &t: v) t += x;",
            "    return v;",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator-=(vector<T> &v, T x) {",
            "    for (T &t: v) t -= x;",
            "    return v;",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator*=(vector<T> &v, T x) {",
            "    for (T &t: v) t *= x;",
            "    return v;",
            "}",
            "",
            "template<class T>",
            "vector<T> &operator/=(vector<T> &v, T x) {",
            "    for (T &t: v) t /= x;",
            "    return v;",
            "}",
            "",
            "struct Init_io {",
            "    Init_io() {",
            "        ios::sync_with_stdio(false);",
            "        cin.tie(nullptr);",
            "        cout.tie(nullptr);",
            "        cout << boolalpha << fixed << setprecision(15);",
            "        cerr << boolalpha << fixed << setprecision(15);",
            "    }",
            "} init_io;",
            "",
            "const string yes[] = {\"no\", \"yes\"};",
            "const string Yes[] = {\"No\", \"Yes\"};",
            "const string YES[] = {\"NO\", \"YES\"};",
            "const int inf = 1001001001;",
            "const ll linf = 1001001001001001001;",
            "",
            "void rearrange(const vi &) {}",
            "",
            "template<class T, class... Tail>",
            "void rearrange(const vi &ord, vector<T> &head, Tail &...tail) {",
            "    assert(ord.size() == head.size());",
            "    vector<T> ori = head;",
            "    rep(i, ord.size()) head[i] = ori[ord[i]];",
            "    rearrange(ord, tail...);",
            "}",
            "",
            "template<class T, class... Tail>",
            "void sort_by(vector<T> &head, Tail &... tail) {",
            "    vi ord(head.size());",
            "    iota(all(ord), 0);",
            "    sort(all(ord), [&](int i, int j) { return head[i] < head[j]; });",
            "    rearrange(ord, head, tail...);",
            "}",
            "",
            "bool in_rect(int i, int j, int h, int w) {",
            "    return 0 <= i and i < h and 0 <= j and j < w;",
            "}",
            "",
            "template<class T>",
            "constexpr vector<T> pow_table(int n, T base) {",
            "    vector<T> res(n, 1);",
            "    rep(i, n - 1) res[i + 1] = res[i] * base;",
            "    return res;",
            "}",
            "",
            "template<class T, class S>",
            "vector<T> cumsum(const vector<S> &v, bool shift_one = true) {",
            "    int n = v.size();",
            "    vector<T> res;",
            "    if (shift_one) {",
            "        res.resize(n + 1);",
            "        rep(i, n) res[i + 1] = res[i] + v[i];",
            "    } else {",
            "        res.resize(n);",
            "        if (n) {",
            "            res[0] = v[0];",
            "            rep(i, 1, n) res[i] = res[i - 1] + v[i];",
            "        }",
            "    }",
            "    return res;",
            "}",
            "",
            "vvi graph(int n, int m, bool directed = false, int origin = 1) {",
            "    vvi G(n);",
            "    rep(_, m) {",
            "        INT(u, v);",
            "        u -= origin, v -= origin;",
            "        G[u].pb(v);",
            "        if (!directed) G[v].pb(u);",
            "    }",
            "    return G;",
            "}",
            "",
            "template<class T>",
            "vector<vector<pair<int, T>>> weighted_graph(int n, int m, bool directed = false, int origin = 1) {",
            "    vector<vector<pair<int, T>>> G(n);",
            "    rep(_, m) {",
            "        int u, v;",
            "        T w;",
            "        scan(u, v, w);",
            "        u -= origin, v -= origin;",
            "        G[u].eb(v, w);",
            "        if (!directed) G[v].eb(u, w);",
            "    }",
            "    return G;",
            "}",
            "",
			"int main(){",
			"   ",
			"}"
        ],
        "description": "yutoさんのテンプレート"
    }
}