{
	"Print to console": {
	"prefix": "tmp",
	"body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"",
		"#pragma GCC target(\"avx\")",
		"#pragma GCC optimize(\"O3\")",
		"#pragma GCC optimize(\"unroll-loops\")",
		"struct Fast {Fast() {std::cin.tie(0); ios::sync_with_stdio(false);}} fast;",
		"",
		"using ull = unsigned long long;",
		"using ll = long long;",
		"using ld = long double;",
		"const ll MOD=1000000007;",
		"const ld EPS=1e-14;",
		"const int INF=1e+9;",
		"const ll LINF=1e+18;",
		"// pair",
		"using pii = pair<int, int>;",
		"// vector",
		"using vi = vector<int>;",
		"using vl = vector<long>;",
		"using vll = vector<ll>;",
		"using vvi = vector<vi>;",
		"using vvl = vector<vl>;",
		"using vvll = vector<vll>;",
		"using vs = vector<string>;",
		"using vpii = vector<pii>;",
		"using vb = vector<bool>;",
		"using vvb = vector<vb>;",
		"// unordered set",
		"using usi = unordered_set<int>;",
		"using usll = unordered_set<ll>;",
		"using uss = unordered_set<string>;",
		"",
		"#define pb push_back",
		"#define mp make_pair",
		"#define um unordered_map",
		"#define siz size()",
		"#define YESNO(bool) if(bool){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}",
		"#define yesno(bool) if(bool){cout<<\"yes\"<<endl;}else{cout<<\"no\"<<endl;}",
		"#define YesNo(bool) if(bool){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}",
		"#define all(v) v.begin(),v.end()",
		"#define rall(v) v.rbegin(),v.rend()",
		"#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );",
		"#define itn int",
		"#define stirng string",
		"",
		"/* REP macro */",
		"#define reps(i, a, n) for (ll i = (a); i < (ll)(n); ++i)",
		"#define rep(i, n) reps(i, 0, n)",
		"#define rrep(i, n) reps(i, 1, n + 1)",
		"#define repd(i,n) for(ll i=n-1;i>=0;i--)",
		"#define rrepd(i,n) for(ll i=n;i>=1;i--)",
		"",
		"/* debug */",
		"// 標準エラー出力を含む提出はrejectされる場合もあるので注意",
		"#define debug(x) cerr << \"\\033[33m(line:\" << __LINE__ << \") \" << #x << \": \" << x << \"\\033[m\" << endl;",
		"",
		"/* func */",
		"inline int in_int() {int x; cin >> x; return x;}",
		"inline ll in_ll() {ll x; cin >> x; return x;}",
		"inline double in_double() {{double x; cin >> x; return x;}}",
		"inline string in_str() {string x; cin >> x; return x;}",
		"inline int ctoi(char c) {return c - '0';}",
		"// vector_finder: (arg)elementを vectorの先頭から(arg)search_lengthまで先頭から検索し、boolを返す",
		"// (arg)search_length: 走査するベクトル長の上限(先頭から何要素目までを検索対象とするか、1始まりで)",
		"template <typename T> inline bool vector_finder(std::vector<T> vec, T element, unsigned int search_length) {",
		"    auto itr = std::find(vec.begin(), vec.end(), element);",
		"    size_t index = std::distance( vec.begin(), itr );",
		"    if (index == vec.size() || index >= search_length) {return false;} else {return true;}",
		"}",
		"template <typename T> inline void print(const vector<T>& v, string s = \" \")",
		"    {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}",
		"template <typename T, typename S> inline void print(const pair<T, S>& p)",
		"    {cout << p.first << \" \" << p.second << endl;}",
		"template <typename T> inline void print(const T& x) {cout << x << \"\\n\";}",
		"template <typename T, typename S> inline void print(const vector<pair<T, S>>& v)",
		"    {for (auto&& p : v) print(p);}",
		"template <typename T, typename S> inline void print(const map<T, S>& m)",
		"    {for (auto&& p : m) print(p);}",
		"inline void dprint(const double& d,ll n = 10){cout << fixed << setprecision(n) << d << endl;}",
		"// 第一引数と第二引数を比較し、第一引数(a)をより大きい/小さい値に上書き",
		"template <typename T> inline bool chmin(T& a, const T& b) {bool compare = a > b; if (a > b) a = b; return compare;}",
		"template <typename T> inline bool chmax(T& a, const T& b) {bool compare = a < b; if (a < b) a = b; return compare;}",
		"",
		"int main(){",
		"   ",
		"}"
	],
	"description": ""
	},
	"inputvec": {
		"body": [
			"vector<${1:int}> ${2:vec}(${3:N});",
			"for (int i = 0; i < $3; i++) cin >> $2[i];",
			""
		],
		"description": "inputvec",
		"prefix": "ivec"
	},
	"inputint": {
		"body": [
			"int ${1:N}; cin>>$1;"
		],
		"description": "inputint",
		"prefix": "iint"
	},
	"inputtwoint": {
		"body": [
			"int ${1:N},${2:M}; cin>>$1>>$2;"
		],
		"description": "inputtwoint",
		"prefix": "iints"
	},
	"inputstring": {
		"body": [
			"string ${1:S}; cin>>$1;"
		],
		"description": "inputstring",
		"prefix": "istr"
	},
	"inputll": {
		"body": [
			"ll ${1:N}; cin>>$1;"
		],
		"description": "inputll",
		"prefix": "ill"
	},
	"inputtwoll": {
		"body": [
			"ll ${1:N},${2:M}; cin>>$1>>$2;"
		],
		"description": "inputtwoll",
		"prefix": "ills"
	},
	"meguru_binary_search": {
		"body": [
			"    // めぐる式二分探索",
			"    // (ng, ok] or [ok, ng)",
			"    // 条件を満たす最小(最大)のindex okと",
			"    // 条件を満たさない最大(最小)のindex ngを探索する",
			"    int ok = ${1:n};  // 条件を満たすindex",
			"    int ng = ${2:-1};   // 条件を満たさないindex",
			"    while (abs(ok - ng) > 1) {",
			"        int mid = (ok + ng) / 2;",
			"        if (${3:isSatisfy}(mid))",
			"            ok = mid;",
			"        else",
			"            ng = mid;",
			"    }",
			""
		],
		"description": "meguru_binary_search",
		"prefix": "meguru_binary_search"
	},
	"uf": {
		"prefix": "UF",
		"body": [
			"struct UnionFind {",
			"    vector<ll> par; // par[i]:iの親の番号(例) par[3] = 2 : 3の親が2",
			"    vector<ll> siz",
			"",
			"    UnionFind(ll N) : par(N),siz(N,1LL) { //最初は全てが根であるとして初期化",
			"        for(ll i = 0; i < N; i++) par[i] = i;",
			"    }",
			"",
			"    void init(ll sz_) {",
			"       par.resize(sz_);",
			"       siz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった",
			"       for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身",
			"    }",
			"",
			"    ll root(ll x) { // データxが属する木の根を再帰で得る:root(x) = {xの木の根}",
			"        if (par[x] == x) return x;",
			"        return par[x] = root(par[x]);",
			"    }",
			"",
			"    bool merge(ll x, ll y) { // xとyの木を併合",
			"        ll rx = root(x); //xの根をrx",
			"        ll ry = root(y); //yの根をry",
			"        if (rx == ry) return false; //xとyの根が同じ(=同じ木にある)時はそのまま",
			"        if(siz[rx] < siz[ry]) swap(rx,ry);",
			"        siz[rx] += siz[ry];",
			"        par[ry] = rx; //xとyの根が同じでない(=同じ木にない)時:xの根rxをyの根ryにつける",
			"        return true;",
			"    }",
			"",
			"    bool issame(ll x, ll y) { // 2つのデータx, yが属する木が同じならtrueを返す",
			"        ll rx = root(x);",
			"        ll ry = root(y);",
			"        return rx == ry;",
			"    }",
			"",
			"   ll size(ll x) {",
			"        return siz[root(x)];",
			"    }",
			"}"
		],
		"description": "UnionFind木"
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"/* RMQ:[0,n-1] について、区間ごとの最小値を管理する構造体",
			"    update(i,x): i 番目の要素を x に更新。O(log(n))",
			"    query(a,b): [a,b) での最小の要素を取得。O(log(n))",
			"*/",
			"template <typename T>",
			"struct RMQ {",
			"    const T INF = numeric_limits<T>::max();",
			"    int n;         // 葉の数",
			"    vector<T> dat; // 完全二分木の配列",
			"    RMQ(int n_) : n(), dat(n_ * 4, INF) { // 葉の数は 2^x の形",
			"        int x = 1;",
			"        while (n_ > x) {",
			"            x *= 2;",
			"        }",
			"        n = x;",
			"    }",
			"",
			"    void update(int i, T x) {",
			"        i += n - 1;",
			"        dat[i] = x;",
			"        while (i > 0) {",
			"            i = (i - 1) / 2;  // parent",
			"            dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);",
			"        }",
			"    }",
			"",
			"    // the minimum element of [a,b)",
			"    T query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
			"    T query_sub(int a, int b, int k, int l, int r) {",
			"        if (r <= a || b <= l) {",
			"            return INF;",
			"        } else if (a <= l && r <= b) {",
			"            return dat[k];",
			"        } else {",
			"            T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
			"            T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
			"            return min(vl, vr);",
			"        }",
			"    }",
			"};"
		],
		"description": "区間内の最小値を求める"
	},
	"iscross": {
		"prefix": "iscross",
		"body": [
			"bool iscross(pair<int,int>p1,pair<int,int>p2,pair<int,int>p3,pair<int,int>p4){",
			"  ll t1,t2,t3,t4;",
			"  t1 = f(p1, p2, p3);",
			"  t2 = f(p1, p2, p4);",
			"  t3 = f(p3, p4, p1);",
			"  t4 = f(p3, p4, p2);",
			"  return t1*t2 < 0.0 && t3*t4 < 0.0;",
			"}"
		],
		"description": "二点を結ぶ線分同士が交わるかどうか"
	},
	"nck": {
		"prefix": "nck",
		"body": [
			"ll nCk(int n, int k) {",
			"    ll x = 1; // n!の初期値",
			"    ll y = 1; // (n-k)!の初期値",
			"    ll z = 1; // k!の初期値",
			"",
			"    // 演算ごとにMODをとる",
			"    rep(i, n) x = (x * (n - i)) % MOD; // n!を計算",
			"    rep(i, n - k) y = (y * (n - k - i)) % MOD; // (n-k)!を計算",
			"    rep(i, k) z = (z * (k - i)) % MOD; // k!を計算",
			"",
			"    // 先に分母をMODの世界で計算してあげる",
			"    ll yz = (y * z) % MOD;",
			"",
			"    // 定義通りに計算",
			"    return (x / (yz)) % MOD;",
			"}",
			""
		],
		"description": "重複なし組み合わせ"
	},
	"Priority_Sum": {
		"prefix": "Priority_Sum",
		"body": [
			"template< typename T, typename Compare = less< T >, typename RCompare = greater< T > >",
			"struct PrioritySumStructure {",
			"",
			"  size_t k;",
			"  T sum;",
			"",
			"  priority_queue< T, vector< T >, Compare > in, d_in;",
			"  priority_queue< T, vector< T >, RCompare > out, d_out;",
			"",
			"  PrioritySumStructure(int k) : k(k), sum(0) {}",
			"",
			"  void modify() {",
			"    while(in.size() - d_in.size() < k && !out.empty()) {",
			"      auto p = out.top();",
			"      out.pop();",
			"      if(!d_out.empty() && p == d_out.top()) {",
			"        d_out.pop();",
			"      } else {",
			"        sum += p;",
			"        in.emplace(p);",
			"      }",
			"    }",
			"    while(in.size() - d_in.size() > k) {",
			"      auto p = in.top();",
			"      in.pop();",
			"      if(!d_in.empty() && p == d_in.top()) {",
			"        d_in.pop();",
			"      } else {",
			"        sum -= p;",
			"        out.emplace(p);",
			"      }",
			"    }",
			"    while(!d_in.empty() && in.top() == d_in.top()) {",
			"      in.pop();",
			"      d_in.pop();",
			"    }",
			"  }",
			"",
			"  T query() const {",
			"    return sum;",
			"  }",
			"",
			"  void insert(T x) {",
			"    in.emplace(x);",
			"    sum += x;",
			"    modify();",
			"  }",
			"",
			"  void erase(T x) {",
			"    assert(size());",
			"    if(!in.empty() && in.top() == x) {",
			"      sum -= x;",
			"      in.pop();",
			"    } else if(!in.empty() && RCompare()(in.top(), x)) {",
			"      sum -= x;",
			"      d_in.emplace(x);",
			"    } else {",
			"      d_out.emplace(x);",
			"    }",
			"    modify();",
			"  }",
			"",
			"  void set_k(size_t kk) {",
			"    k = kk;",
			"    modify();",
			"  }",
			"",
			"  size_t get_k() const {",
			"    return k;",
			"  }",
			"",
			"  size_t size() const {",
			"    return in.size() + out.size() - d_in.size() - d_out.size();",
			"  }",
			"};",
			"",
			"template< typename T >",
			"using MaximumSum = PrioritySumStructure< T, greater< T >, less< T > >;",
			"",
			"template< typename T >",
			"using MinimumSum = PrioritySumStructure< T, less< T >, greater< T > >;",
			""
		],
		"description": "スライド区間内の小さい・大きい順にK個の和"
	},
	"isPrime": {
		"prefix": "isPrime",
		"body": [
			"bool IsPrime(int num)",
			"{",
			"    if (num < 2) return false;",
			"    else if (num == 2) return true;",
			"    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く",
			"",
			"    double sqrtNum = sqrt(num);",
			"    for (int i = 3; i <= sqrtNum; i += 2)",
			"    {",
			"        if (num % i == 0)",
			"        {",
			"            // 素数ではない",
			"            return false;",
			"        }",
			"    }",
			"",
			"    // 素数である",
			"    return true;",
			"}"
		],
		"description": "素数判定"
	},
	"powmod": {
		"prefix": "powmod",
		"body": [
			"ll powmod(ll x,ll y){",
			"    ll res=1;",
			"    for(ll i=0;i<y;i++){",
			"      res=res*x%MOD;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	}
}